{% extends '../../BaseClassifier.jinja' %}

{% block predict %}

    float kernels[{{ support_vectors | length }}] = { 0 };

    {% if num_classes > 1 %}
        float decisions[{{ num_classes * (num_classes - 1) // 2 }}] = { 0 };
        int votes[{{ num_classes }}] = { 0 };
    {% endif %}

    {% for i, w in enumerate(support_vectors) %}
        kernels[{{ i }}] = compute_kernel(x, {{ num_inputs }}, {{ w | to_array(with_parentheses=False) }});
    {% endfor %}

    {% if num_classes == 1 %}
        float decision = {{ intercepts[0] | round(9) }}f - ({% for i, coef in enumerate(coefs[0]) %} + kernels[{{ i }}] {% if coef != 1 %}* {{ coef | round(9) }}f{% endif %} {% endfor %});

        return decision > 0 ? 0 : 1;

    {% elif num_classes == 2 %}
        float decision =
            {{ intercepts[0] | round(9) }}f
            + {% for i, coef in enumerate(coefs[0]) %}
                {% if coef == 1 %}
                    + kernels[{{ i }}]
                {% elif coef == -1 %}
                    - kernels[{{ i }}]
                {% elif coef != 0 %}
                    + kernels[{{ i }}] * {{ coef | round(9) }}f
                {% endif %}
            {% endfor %};

        return decision > 0 ? 1 : 0;
    {% else %}
        {% set helpers = {'ii': 0} %}

        {% for i in range(0, num_classes) %}
            {% for j in range(i + 1, num_classes) %}
                {% set start_i = n_support[:i].sum() %}
                {% set start_j = n_support[:j].sum() %}

                decisions[{{ helpers.ii }}] = {{ intercepts[helpers.ii] | round(9) }}f

                {% for k in range(start_i, start_i + n_support[i]) %}
                    {% with coef = coefs[j-1][k] %}
                        {% if coef == 1 %}
                            + kernels[{{ k }}]
                        {% elif coef == -1 %}
                            - kernels[{{ k }}]
                        {% elif coef != 0 %}
                            + kernels[{{ k }}] * {{ coef | round(9) }}f
                        {% endif %}
                    {% endwith %}
                {% endfor %}

                {% for k in range(start_j, start_j + n_support[j]) %}
                    {% with coef = coefs[i][k] %}
                        {% if coef == 1 %}
                            + kernels[{{ k }}]
                        {% elif coef == -1 %}
                            - kernels[{{ k }}]
                        {% elif coef != 0 %}
                            + kernels[{{ k }}] * {{ coef | round(9) }}f
                        {% endif %}
                    {% endwith %}
                {% endfor %};

                {% if helpers.update({'ii': helpers.ii + 1}) %}{% endif %}
            {% endfor %}
        {% endfor %}

        {% include '../../partials/vote_ovo.jinja' %}
        {% include '../../partials/vote.jinja' %}
    {% endif %}
{% endblock %}

{% block protected %}
    /**
     * Compute kernel between feature vector and support vector
     * Kernel type: {{ kernel['type'] }}
     * Kernel gamma: {{ kernel['gamma'] }}
     * Kernel coef: {{ kernel['coef0'] }}
     * Kernel degree: {{ kernel['degree'] }}
     */
    float compute_kernel(float *x, int num_inputs, ...) {
        float kernel = 0.0f;
        va_list w;
        va_start(w, num_inputs);

        for (uint16_t i = 0; i < {{ num_inputs }}; i++) {
            const float wi = va_arg(w, double);

            {% if kernel['type'] in ['linear', 'poly', 'sigmoid'] %}
                kernel += x[i] * wi;
            {% elif kernel['type'] == 'rbf' %}
                kernel += pow(x[i] - wi, 2);
            {% else %}
                #error "UNKNOWN KERNEL {{ kernel['type'] }}";
            {% endif %}
        }

        {% if kernel['type'] == 'poly' %}
            return pow(({{ kernel['gamma'] }} * kernel) + {{ kernel['coef0'] }}, {{ kernel['degree'] }});
        {% elif kernel['type'] == 'rbf' %}
            return exp(-{{ kernel['gamma'] }} * kernel);
        {% elif kernel['type'] == 'sigmoid' %}
            return sigmoid(({{ kernel['gamma'] }} * kernel) + {{ kernel['coef0'] }});
        {% else %}
            return kernel;
        {% endif %}
    }

    /**
     * Sigmoid of x
     */
    float sigmoid(float x) {
        float t = pow(2.7182818284f, x);

        return t / (t + 1);
    }
{% endblock %}