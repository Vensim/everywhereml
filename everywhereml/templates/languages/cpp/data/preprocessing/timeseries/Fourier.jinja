{% extends '../BaseTransformer.jinja' %}

{% block transform %}
    // compute all features in parallel
    float harmonic = {{ 2 * PI / num_samples }}f;

    {% if lookup %}
        float lookup[{{ lookup | shape }}] = {{ lookup | to_array }};
    {% endif %}

    // optimized case for f=0
    for (uint16_t k = 0, offset = 0; k < {{ num_features }}; k++, offset += {{ fft_length }}) {
        float sum = 0;

        for (uint16_t i = k; i < {{ input_dim }}; i += {{ num_features }}) {
            sum += source[i];
        }

        buffer[offset] = sum;
    }

    for (uint16_t f = 1; f < {{ fft_length }}; f++) {
        float re[{{ num_features }}] = {0};
        float im[{{ num_features }}] = {0};

        for (uint16_t i = 0, offset = 0; i < {{ num_samples }}; i++, offset += {{ num_features }}) {
            const float harmonic_i = harmonic * i;

            {% if lookup %}
                // lookup cosine and interpolate
                const uint8_t idx = harmonic_i * {{ 180 / 2 / PI }} + 1;
                const float cos_i = (lookup[idx - 1] + lookup[idx] + lookup[idx + 1]) / 3;
            {% else %}
                const float cos_i = cos(harmonic_i);
            {% endif %}
            // sqrt() is faster than sin()
            const float unsigned_sin_i = sqrt(1 - cos_i * cos_i);
            const float sin_i = harmonic_i > {{ PI / 2 }}f ? -unsigned_sin_i : unsigned_sin_i;

            for (uint16_t k = 0; k < {{ num_features }}; k++) {
                float s = source[offset + k];

                re[k] += s * cos_i;
                im[k] += s * sin_i;
            }
        }

        // append computed values
        for (uint16_t k = 0, offset = f; k < {{ num_features }}; k++, offset += {{ fft_length }}) {
            buffer[offset] = sqrt(re[k] * re[k] + im[k] * im[k]);
        }

        harmonic += {{ 2 * PI / num_samples }}f;
    }

    memcpy(source, buffer, sizeof(float) * {{ num_features * fft_length }});

{% endblock %}